# File: Dockerfile

FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

RUN python -m unittest discover tests

EXPOSE 8000

CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:8000", "app:app"]

# File: requirements.txt

numpy==1.21.0
scikit-learn==0.24.2
flask==2.0.1
gunicorn==20.1.0
prometheus-client==0.11.0

# File: app.py

from flask import Flask, request, jsonify
from katabatic.models.production_model import ProductionModel
from prometheus_client import make_wsgi_app
from werkzeug.middleware.dispatcher import DispatcherMiddleware
from werkzeug.serving import run_simple
import logging

app = Flask(__name__)

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize the model
model = ProductionModel()

@app.route('/predict', methods=['POST'])
def predict():
    data = request.json
    try:
        result = model.generate(data)
        return jsonify({"prediction": result})
    except Exception as e:
        logger.error(f"Prediction error: {str(e)}")
        return jsonify({"error": "Prediction failed"}), 500

@app.route('/train', methods=['POST'])
def train():
    data = request.json
    try:
        model.fit(data['X'], data['y'])
        return jsonify({"message": "Model trained successfully"})
    except Exception as e:
        logger.error(f"Training error: {str(e)}")
        return jsonify({"error": "Training failed"}), 500

# Add prometheus wsgi middleware to route /metrics requests
app.wsgi_app = DispatcherMiddleware(app.wsgi_app, {
    '/metrics': make_wsgi_app()
})

if __name__ == '__main__':
    run_simple(hostname="0.0.0.0", port=8000, application=app)

# File: katabatic/models/production_model.py

import numpy as np
from sklearn.ensemble import RandomForestRegressor
from katabatic.models.model import Model

class ProductionModel(Model):
    def __init__(self):
        super().__init__("production_model")
        self.model = RandomForestRegressor()

    def fit(self, X, y):
        self.model.fit(X, y)

    def generate(self, X):
        return self.model.predict(X)

    def evaluate(self, X, y):
        return self.model.score(X, y)

# File: tests/test_production_model.py

import unittest
import numpy as np
from katabatic.models.production_model import ProductionModel

class TestProductionModel(unittest.TestCase):
    def setUp(self):
        self.model = ProductionModel()

    def test_fit_and_generate(self):
        X = np.array([[1, 2], [3, 4], [5, 6]])
        y = np.array([1, 2, 3])
        self.model.fit(X, y)
        predictions = self.model.generate(X)
        self.assertEqual(len(predictions), 3)

    def test_evaluate(self):
        X = np.array([[1, 2], [3, 4], [5, 6]])
        y = np.array([1, 2, 3])
        self.model.fit(X, y)
        score = self.model.evaluate(X, y)
        self.assertIsInstance(score, float)
        self.assertGreaterEqual(score, 0)
        self.assertLessEqual(score, 1)

if __name__ == '__main__':
    unittest.main()

# File: .dockerignore

__pycache__
*.pyc
*.pyo
*.pyd
.Python
env
pip-log.txt
pip-delete-this-directory.txt
.tox
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.log
.git
.mypy_cache
.pytest_cache
.hypothesis

# File: docker-compose.yml

version: '3'

services:
  katabatic-model:
    build: .
    ports:
      - "8000:8000"
    environment:
      - FLASK_ENV=production
    volumes:
      - ./data:/app/data
    restart: always

# File: .env

FLASK_ENV=production
MODEL_VERSION=1.0.0
LOGGING_LEVEL=INFO

# File: scripts/run_tests.sh

#!/bin/bash
set -e

echo "Running unit tests..."
python -m unittest discover tests

echo "Running integration tests..."
# Add your integration test command here

echo "All tests passed!"

# File: scripts/deploy.sh

#!/bin/bash
set -e

echo "Building Docker image..."
docker build -t katabatic-model:latest .

echo "Running tests..."
./scripts/run_tests.sh

echo "Pushing to container registry..."
# Add your push command here, e.g.:
# docker push your-registry.com/katabatic-model:latest

echo "Deploying to production..."
# Add your deployment command here, e.g.:
# kubectl apply -f k8s/deployment.yaml

echo "Deployment complete!"
